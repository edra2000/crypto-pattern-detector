<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>كاشف الأنماط الفنية للعملات الرقمية - احترافي</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%); color: #fff; min-height: 100vh; margin: 0; direction: rtl; }
    .container { max-width: 1400px; margin: 0 auto; padding: 2rem; }
    .header { text-align: center; margin-bottom: 2rem; padding: 1.5rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.3);}
    .controls { display: flex; gap: 1rem; margin-bottom: 2rem; flex-wrap: wrap; justify-content: center; }
    .search-container { position: relative; flex: 1; max-width: 300px; }
    .search-container input { width: 100%; padding: 1rem 1rem 1rem 3rem; border: 2px solid #333; border-radius: 25px; background: #1a1a1a; color: #fff; font-size: 1rem; transition: all 0.3s; }
    .search-container i { position: absolute; right: 1rem; top: 50%; transform: translateY(-50%); color: #888; }
    .refresh-btn { padding: 1rem 2rem; background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%); border: none; border-radius: 25px; color: #000; font-weight: bold; cursor: pointer; font-size: 1rem; }
    .refresh-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0, 212, 255, 0.4); }
    .loading { text-align: center; padding: 3rem 2rem; display: none; }
    .loading.show { display: block; }
    .loading-spinner { width: 60px; height: 60px; border: 4px solid #333; border-top: 4px solid #00d4ff; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 2rem; }
    @keyframes spin { 0% {transform:rotate(0);} 100% {transform:rotate(360deg);} }
    .cards-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 2rem; margin-top: 2rem; }
    .crypto-card { background: linear-gradient(145deg, #1e1e1e, #2a2a2a); border-radius: 20px; padding: 1.5rem; box-shadow: 0 8px 25px rgba(0,0,0,0.3); transition: all 0.3s; border: 1px solid #333;}
    .crypto-card:hover { transform: translateY(-5px) scale(1.02); box-shadow: 0 15px 35px rgba(0, 212, 255, 0.2); border-color: #00d4ff; }
    .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
    .coin-info h3 { font-size: 1.3rem; margin-bottom: 0.25rem; color: #00d4ff; }
    .coin-info .symbol { color: #888; font-size: 0.9rem; }
    .price-info { text-align: left; }
    .price { font-size: 1.2rem; font-weight: bold; margin-bottom: 0.25rem; }
    .change { font-size: 0.9rem; padding: 0.25rem 0.5rem; border-radius: 10px; }
    .change.positive { background: rgba(46,213,115,0.2); color: #2ed573; }
    .change.negative { background: rgba(255,71,87,0.2); color: #ff4757; }
    .pattern-info { margin: 1rem 0; padding: 1rem; background: rgba(0,212,255,0.1); border-radius: 10px; border-right: 4px solid #00d4ff; }
    .pattern-name { font-weight: bold; color: #00d4ff; margin-bottom: 0.5rem; }
    .pattern-details { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 0.9rem; }
    .detail-item { display: flex; justify-content: space-between; }
    .detail-label { color: #888; }
    .detail-value { font-weight: bold; }
    .targets { display: flex; justify-content: space-between; margin-top: 1rem; gap: 0.5rem; }
    .target { flex: 1; text-align: center; padding: 0.75rem; border-radius: 10px; font-size: 0.85rem; }
    .target1 { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    .target2 { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
    .stop-loss { background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%); color: #000; }
    .error-message { text-align: center; padding: 3rem; color: #ff4757; }
    .error-message i { font-size: 3rem; margin-bottom: 1rem; }
    @media (max-width: 768px) { .container { padding: 1rem; } .header h1 { font-size: 2rem; } .cards-grid { grid-template-columns: 1fr; gap: 1rem; } .controls { flex-direction: column; } .search-container { max-width: 100%; } }
  </style>
</head>
<body>
  <div class="container">
    <header class="header">
      <h1><i class="fas fa-chart-line"></i> كاشف الأنماط الفنية</h1>
      <p>تحليل حقيقي للأنماط الفنية في العملات الرقمية (Spot فقط)</p>
    </header>
    <div class="controls">
      <div class="search-container">
        <i class="fas fa-search"></i>
        <input type="text" id="searchInput" placeholder="البحث عن عملة...">
      </div>
      <button id="refreshBtn" class="refresh-btn"><i class="fas fa-sync-alt"></i> تحديث البيانات</button>
    </div>
    <div id="loading" class="loading">
      <div class="loading-spinner"></div>
      <h3>جاري تحليل الأنماط الفنية...</h3>
      <p>جاري فحص جميع عملات السوق الفوري (Spot) وتحليل الأنماط</p>
    </div>
    <div id="cardsGrid" class="cards-grid"></div>
  </div>
  <script>
    // قائمة العملات المستقرة الشائعة
    const stableCoins = ["USDT", "BUSD", "USDC", "TUSD", "USDP", "DAI", "FDUSD", "SUSD", "EUR", "GBP", "TRY", "BRL", "IDRT", "UAH", "NGN", "ZAR", "RUB", "VAI"];
    // الكلاس الأساسي
    class PatternDetector {
      constructor() {
        this.cryptoData = new Map();
        this.isLoading = false;
        this.allSymbols = [];
        this.init();
      }
      async init() {
        this.setupEventListeners();
        await this.loadData();
      }
      setupEventListeners() {
        document.getElementById('refreshBtn').onclick = () => !this.isLoading && this.loadData();
        document.getElementById('searchInput').oninput = e => this.filterCards(e.target.value);
      }
      showLoading(show) {
        document.getElementById('loading').classList.toggle('show', show);
        document.getElementById('cardsGrid').style.display = show ? 'none' : 'grid';
        this.isLoading = show;
      }
      // جلب جميع أزواج السوق الفوري USDT فقط واستبعاد المستقرة
      async getSpotSymbols() {
        const res = await fetch("https://api.binance.com/api/v3/exchangeInfo");
        const data = await res.json();
        // فقط أزواج spot وليس future
        const symbols = data.symbols.filter(s =>
          s.status === "TRADING" &&
          s.isSpotTradingAllowed &&
          s.symbol.endsWith("USDT") &&
          !stableCoins.some(stable => s.baseAsset === stable || s.quoteAsset === stable) &&
          !s.symbol.includes("UPUSDT") && !s.symbol.includes("DOWNUSDT") &&
          !s.symbol.includes("BULLUSDT") && !s.symbol.includes("BEARUSDT")
        ).map(s => s.symbol);
        return symbols;
      }
      async loadData() {
        try {
          this.showLoading(true);
          this.cryptoData.clear();
          // جلب قائمة العملات الصحيحة من السوق الفوري
          if (!this.allSymbols.length) this.allSymbols = await this.getSpotSymbols();
          const symbols = this.allSymbols;
          // تحميل البيانات بشكل متوازي مع حد أقصى للطلبات في الوقت نفسه (مثلاً كل 20 عملة)
          let results = [];
          const batchSize = 20;
          for (let i = 0; i < symbols.length; i += batchSize) {
            const batch = symbols.slice(i, i + batchSize);
            const batchResults = await Promise.all(batch.map(symbol => this.analyzeSymbol(symbol)));
            results = results.concat(batchResults);
            // تأخير بسيط لتقليل الضغط على API
            await this.sleep(800);
          }
          results.forEach(data => {
            if (data && data.patternDetected) this.cryptoData.set(data.symbol, data);
          });
          this.renderCards();
        } catch (error) {
          this.showError('حدث خطأ في تحميل البيانات. يرجى المحاولة مرة أخرى.');
        } finally {
          this.showLoading(false);
        }
      }
      async analyzeSymbol(symbol) {
        try {
          // جلب بيانات السعر الحالي
          const priceRes = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`);
          if (!priceRes.ok) throw new Error();
          const priceData = await priceRes.json();
          // جلب بيانات الشموع
          const candlesRes = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=100`);
          if (!candlesRes.ok) throw new Error();
          const candlesData = await candlesRes.json();
          const candles = candlesData.map(c => ({
            open: +c[1], high: +c[2], low: +c[3], close: +c[4], volume: +c[5], time: new Date(c[0])
          }));
          // تحليل الأنماط الفنية
          const pattern = this.detectPattern(candles);
          if (!pattern.detected) return null;
          return {
            symbol,
            name: symbol.replace('USDT', ''),
            price: +priceData.lastPrice,
            change: +priceData.priceChangePercent,
            volume: +priceData.volume,
            pattern: pattern.type,
            patternName: pattern.name,
            confidence: pattern.confidence,
            breakoutStatus: pattern.breakoutStatus,
            signalStrength: pattern.signalStrength,
            targets: pattern.targets,
            patternDetected: true,
            lastUpdate: new Date()
          };
        } catch {
          return null;
        }
      }
      // خوارزميات الأنماط كما في النسخة السابقة
      detectPattern(candles) {
        if (candles.length < 50) return {detected:false};
        const lows = candles.map(c=>c.low), highs = candles.map(c=>c.high), vols = candles.map(c=>c.volume);
        const doubleBottom = this.findDoubleBottom(lows, vols);
        if (doubleBottom.detected) return doubleBottom;
        const doubleTop = this.findDoubleTop(highs, vols);
        if (doubleTop.detected) return doubleTop;
        const ascendingTriangle = this.findAscendingTriangle(highs, lows);
        if (ascendingTriangle.detected) return ascendingTriangle;
        return {detected:false};
      }
      findDoubleBottom(lows, volumes) {
        const len = lows.length;
        if (len < 30) return { detected: false };
        for (let i=10; i<len-20; i++) {
          for (let j=i+10; j<len-10; j++) {
            const bottom1 = lows[i], bottom2 = lows[j], diff = Math.abs(bottom1-bottom2)/bottom1;
            if (diff < 0.03) {
              const middleHigh = Math.max(...lows.slice(i,j));
              const currentPrice = lows[len-1];
              if (middleHigh > bottom1*1.05) {
                const confidence = this.calculateConfidence(diff, volumes, i, j);
                const targets = this.calculateTargets(bottom1, middleHigh, 'bullish');
                return {
                  detected:true, type:'double-bottom',
                  name:'القاع المزدوج',
                  confidence: `${Math.round(confidence)}%`,
                  breakoutStatus: currentPrice>middleHigh?'مؤكد':'في انتظار التأكيد',
                  signalStrength: confidence>75?'قوية':confidence>60?'متوسطة':'ضعيفة',
                  targets
                };
              }
            }
          }
        }
        return { detected: false };
      }
      findDoubleTop(highs, volumes) {
        const len=highs.length;
        if (len<30) return { detected: false };
        for (let i=10; i<len-20; i++) {
          for (let j=i+10; j<len-10; j++) {
            const top1=highs[i], top2=highs[j], diff=Math.abs(top1-top2)/top1;
            if (diff<0.03) {
              const middleLow=Math.min(...highs.slice(i,j));
              const currentPrice=highs[len-1];
              if (middleLow<top1*0.95) {
                const confidence=this.calculateConfidence(diff,volumes,i,j);
                const targets=this.calculateTargets(top1,middleLow,'bearish');
                return {
                  detected:true, type:'double-top',
                  name:'القمة المزدوجة',
                  confidence: `${Math.round(confidence)}%`,
                  breakoutStatus: currentPrice<middleLow?'مؤكد':'في انتظار التأكيد',
                  signalStrength: confidence>75?'قوية':confidence>60?'متوسطة':'ضعيفة',
                  targets
                };
              }
            }
          }
        }
        return { detected: false };
      }
      findAscendingTriangle(highs, lows) {
        const len=highs.length;
        if (len<40) return { detected: false };
        const recent=len-30;
        const recentHighs=highs.slice(recent), recentLows=lows.slice(recent);
        const resistance=Math.max(...recentHighs);
        const resistanceCount=recentHighs.filter(h=>Math.abs(h-resistance)/resistance<0.02).length;
        const lowTrend=this.calculateTrend(recentLows);
        if (resistanceCount>=2 && lowTrend>0) {
          const confidence=Math.min(90,60+(resistanceCount*5)+(lowTrend*100));
          const currentPrice=highs[len-1];
          const support=Math.min(...recentLows);
          const targets=this.calculateTargets(resistance,support,'bullish');
          return {
            detected:true, type:'ascending-triangle',
            name:'المثلث الصاعد',
            confidence: `${Math.round(confidence)}%`,
            breakoutStatus: currentPrice>resistance?'مؤكد':'في انتظار التأكيد',
            signalStrength: confidence>75?'قوية':confidence>60?'متوسطة':'ضعيفة',
            targets
          };
        }
        return { detected: false };
      }
      calculateConfidence(priceDiff, volumes, index1, index2) {
        let confidence=70;
        confidence-=(priceDiff*1000);
        const avgVolume=volumes.reduce((a,b)=>a+b,0)/volumes.length;
        const volume1=volumes[index1]||avgVolume, volume2=volumes[index2]||avgVolume;
        if (volume1>avgVolume*1.2) confidence+=5;
        if (volume2>avgVolume*1.2) confidence+=5;
        return Math.max(50,Math.min(95,confidence));
      }
      calculateTargets(price1, price2, direction) {
        const range=Math.abs(price1-price2);
        if (direction==='bullish') {
          const breakoutLevel=Math.max(price1,price2);
          return {
            target1: `$${(breakoutLevel+range*0.618).toFixed(4)}`,
            target2: `$${(breakoutLevel+range*1.0).toFixed(4)}`,
            stopLoss: `$${(Math.min(price1,price2)*0.98).toFixed(4)}`
          };
        } else {
          const breakoutLevel=Math.min(price1,price2);
          return {
            target1: `$${(breakoutLevel-range*0.618).toFixed(4)}`,
            target2: `$${(breakoutLevel-range*1.0).toFixed(4)}`,
            stopLoss: `$${(Math.max(price1,price2)*1.02).toFixed(4)}`
          };
        }
      }
      calculateTrend(prices) {
        if (prices.length<10) return 0;
        const n=prices.length, sumX=(n*(n-1))/2, sumY=prices.reduce((a,b)=>a+b,0),
          sumXY=prices.reduce((sum,price,index)=>sum+(price*index),0),
          sumX2=(n*(n-1)*(2*n-1))/6;
        const slope=(n*sumXY-sumX*sumY)/(n*sumX2-sumX*sumX);
        return slope/(sumY/n);
      }
      renderCards() {
        const grid = document.getElementById('cardsGrid');
        if (this.cryptoData.size === 0) {
          grid.innerHTML = `
            <div class="error-message">
              <i class="fas fa-search"></i>
              <h3>لم يتم العثور على أنماط فنية</h3>
              <p>جرب التحديث مرة أخرى أو تحقق من اتصال الإنترنت</p>
            </div>`;
          return;
        }
        const cards = Array.from(this.cryptoData.values())
          .sort((a,b)=>{
            const sOrder={ 'قوية':3, 'متوسطة':2, 'ضعيفة':1 };
            const aS=sOrder[a.signalStrength]||0, bS=sOrder[b.signalStrength]||0;
            if (aS!==bS) return bS-aS;
            return parseInt(b.confidence)-parseInt(a.confidence);
          })
          .map(crypto => this.createCard(crypto)).join('');
        grid.innerHTML = cards;
      }
      createCard(crypto) {
        const changeClass=crypto.change>=0?'positive':'negative';
        const changeIcon=crypto.change>=0?'fa-arrow-up':'fa-arrow-down';
        const patternIcon = {
          'double-bottom': 'fa-chart-line',
          'double-top': 'fa-chart-line',
          'ascending-triangle': 'fa-play'
        }[crypto.pattern] || 'fa-chart-bar';
        const strengthColors = { 'قوية': '#2ed573', 'متوسطة': '#ffa502', 'ضعيفة': '#ff4757' };
        const strengthColor = strengthColors[crypto.signalStrength] || '#888';
        return `
        <div class="crypto-card" data-symbol="${crypto.symbol}">
          <div class="card-header">
            <div class="coin-info">
              <h3><i class="fab fa-bitcoin"></i> ${crypto.name}</h3>
              <span class="symbol">${crypto.symbol}</span>
            </div>
            <div class="price-info">
              <div class="price">$${crypto.price.toFixed(4)}</div>
              <div class="change ${changeClass}">
                <i class="fas ${changeIcon}"></i>
                ${crypto.change.toFixed(2)}%
              </div>
            </div>
          </div>
          <div class="pattern-info">
            <div class="pattern-name">
              <i class="fas ${patternIcon}"></i>
              ${crypto.patternName}
            </div>
            <div class="pattern-details">
              <div class="detail-item">
                <span class="detail-label">مستوى الثقة:</span>
                <span class="detail-value">${crypto.confidence}</span>
              </div>
              <div class="detail-item">
                <span class="detail-label">قوة الإشارة:</span>
                <span class="detail-value" style="color:${strengthColor};">${crypto.signalStrength}</span>
              </div>
              <div class="detail-item">
                <span class="detail-label">حالة الاختراق:</span>
                <span class="detail-value">${crypto.breakoutStatus}</span>
              </div>
              <div class="detail-item">
                <span class="detail-label">آخر تحديث:</span>
                <span class="detail-value">${this.formatTime(crypto.lastUpdate)}</span>
              </div>
            </div>
          </div>
          <div class="targets">
            <div class="target target1">
              <div style="font-weight:bold;margin-bottom:0.25rem;">الهدف الأول</div>
              <div>${crypto.targets.target1}</div>
            </div>
            <div class="target target2">
              <div style="font-weight:bold;margin-bottom:0.25rem;">الهدف الثاني</div>
              <div>${crypto.targets.target2}</div>
            </div>
            <div class="target stop-loss">
              <div style="font-weight:bold;margin-bottom:0.25rem;">وقف الخسارة</div>
              <div>${crypto.targets.stopLoss}</div>
            </div>
          </div>
        </div>
        `;
      }
      formatTime(date) {
        const now=new Date(), diff=now-date, minutes=Math.floor(diff/60000);
        if (minutes<1) return 'الآن';
        if (minutes<60) return `${minutes} دقيقة`;
        const hours=Math.floor(minutes/60);
        if (hours<24) return `${hours} ساعة`;
        const days=Math.floor(hours/24);
        return `${days} يوم`;
      }
      filterCards(term) {
        const cards = document.querySelectorAll('.crypto-card');
        term = term.toLowerCase();
        cards.forEach(card=>{
          const symbol=card.dataset.symbol.toLowerCase();
          const name=card.querySelector('.coin-info h3').textContent.toLowerCase();
          const pattern=card.querySelector('.pattern-name').textContent.toLowerCase();
          card.style.display = symbol.includes(term)||name.includes(term)||pattern.includes(term) ? 'block':'none';
        });
      }
      showError(msg) {
        document.getElementById('cardsGrid').innerHTML=`
          <div class="error-message">
            <i class="fas fa-exclamation-triangle"></i>
            <h3>حدث خطأ</h3>
            <p>${msg}</p>
            <button onclick="location.reload()" class="refresh-btn" style="margin-top:1rem;">إعادة المحاولة</button>
          </div>
        `;
      }
      sleep(ms) { return new Promise(res=>setTimeout(res,ms)); }
    }
    // بدء تشغيل التطبيق
    document.addEventListener('DOMContentLoaded', () => {
      window.patternDetector = new PatternDetector();
    });
    // تحديث تلقائي كل 5 دقائق
    setInterval(() => {
      if (window.patternDetector && !window.patternDetector.isLoading) window.patternDetector.loadData();
    }, 300000);
  </script>
</body>
</html>
