<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÙƒØ§Ø´Ù Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„ÙÙ†ÙŠØ© Ù„Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ø±Ù‚Ù…ÙŠØ©</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            color: #fff;
            min-height: 100vh;
            direction: rtl;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .search-container {
            position: relative;
            flex: 1;
            max-width: 300px;
        }

        .search-container input {
            width: 100%;
            padding: 1rem 1rem 1rem 3rem;
            border: 2px solid #333;
            border-radius: 25px;
            background: #1a1a1a;
            color: #fff;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .search-container input:focus {
            outline: none;
            border-color: #00d4ff;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        .search-container i {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: #888;
        }

        .refresh-btn {
            padding: 1rem 2rem;
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            border: none;
            border-radius: 25px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }

        .refresh-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.4);
        }

        .loading {
            text-align: center;
            padding: 4rem 2rem;
            display: none;
        }

        .loading.show {
            display: block;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #333;
            border-top: 4px solid #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 2rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 2rem;
            margin-top: 2rem;
        }

        .crypto-card {
            background: linear-gradient(145deg, #1e1e1e, #2a2a2a);
            border-radius: 20px;
            padding: 1.5rem;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            border: 1px solid #333;
        }

        .crypto-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 212, 255, 0.2);
            border-color: #00d4ff;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .coin-info h3 {
            font-size: 1.3rem;
            margin-bottom: 0.25rem;
            color: #00d4ff;
        }

        .coin-info .symbol {
            color: #888;
            font-size: 0.9rem;
        }

        .price-info {
            text-align: left;
        }

        .price {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        .change {
            font-size: 0.9rem;
            padding: 0.25rem 0.5rem;
            border-radius: 10px;
        }

        .change.positive {
            background: rgba(46, 213, 115, 0.2);
            color: #2ed573;
        }

        .change.negative {
            background: rgba(255, 71, 87, 0.2);
            color: #ff4757;
        }

        .pattern-info {
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 10px;
            border-right: 4px solid #00d4ff;
        }

        .pattern-name {
            font-weight: bold;
            color: #00d4ff;
            margin-bottom: 0.5rem;
        }

        .pattern-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
        }

        .detail-label {
            color: #888;
        }

        .detail-value {
            font-weight: bold;
        }

        .targets {
            display: flex;
            justify-content: space-between;
            margin-top: 1rem;
            gap: 0.5rem;
        }

        .target {
            flex: 1;
            text-align: center;
            padding: 0.75rem;
            border-radius: 10px;
            font-size: 0.85rem;
        }

        .target1 {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .target2 {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .stop-loss {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            color: #000;
        }

        .error-message {
            text-align: center;
            padding: 3rem;
            color: #ff4757;
        }

        .error-message i {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .cards-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .search-container {
                max-width: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1><i class="fas fa-chart-line"></i> ÙƒØ§Ø´Ù Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„ÙÙ†ÙŠØ©</h1>
            <p>ØªØ­Ù„ÙŠÙ„ Ø­Ù‚ÙŠÙ‚ÙŠ Ù„Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„ÙÙ†ÙŠØ© ÙÙŠ Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ø±Ù‚Ù…ÙŠØ©</p>
        </header>

        <div class="controls">
            <div class="search-container">
                <i class="fas fa-search"></i>
                <input type="text" id="searchInput" placeholder="Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¹Ù…Ù„Ø©...">
            </div>
            <button id="refreshBtn" class="refresh-btn">
                <i class="fas fa-sync-alt"></i>
                ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            </button>
        </div>

        <div id="loading" class="loading">
            <div class="loading-spinner"></div>
            <h3>Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„ÙÙ†ÙŠØ©...</h3>
            <p>ÙŠØªÙ… ÙØ­Øµ Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ø±Ù‚Ù…ÙŠØ© ÙˆØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø·</p>
        </div>

        <div id="cardsGrid" class="cards-grid"></div>
    </div>

    <script>
        class PatternDetector {
            constructor() {
                this.cryptoData = new Map();
                this.isLoading = false;
                this.init();
            }

            async init() {
                console.log('ğŸš€ Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ ÙƒØ§Ø´Ù Ø§Ù„Ø£Ù†Ù…Ø§Ø·...');
                this.setupEventListeners();
                await this.loadData();
            }

            setupEventListeners() {
                const refreshBtn = document.getElementById('refreshBtn');
                const searchInput = document.getElementById('searchInput');

                refreshBtn.addEventListener('click', () => {
                    if (!this.isLoading) {
                        this.loadData();
                    }
                });

                searchInput.addEventListener('input', (e) => {
                    this.filterCards(e.target.value);
                });
            }

            showLoading(show) {
                const loading = document.getElementById('loading');
                const grid = document.getElementById('cardsGrid');
                
                if (show) {
                    loading.classList.add('show');
                    grid.style.display = 'none';
                    this.isLoading = true;
                } else {
                    loading.classList.remove('show');
                    grid.style.display = 'grid';
                    this.isLoading = false;
                }
            }

            async loadData() {
                try {
                    this.showLoading(true);
                    console.log('ğŸ“Š Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...');
                    
                    // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©
                    const symbols = [
                        'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'ADAUSDT', 'XRPUSDT',
                        'SOLUSDT', 'DOTUSDT', 'DOGEUSDT', 'AVAXUSDT', 'SHIBUSDT',
                        'MATICUSDT', 'LTCUSDT', 'UNIUSDT', 'LINKUSDT', 'ATOMUSDT',
                        'ETCUSDT', 'XLMUSDT', 'BCHUSDT', 'FILUSDT', 'TRXUSDT'
                    ];

                    this.cryptoData.clear();
                    
                    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ Ù…ØªØªØ§Ù„ÙŠ Ù„ØªØ¬Ù†Ø¨ Ø­Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª
                    for (let i = 0; i < symbols.length; i++) {
                        try {
                            const symbol = symbols[i];
                            console.log(`ğŸ“ˆ ØªØ­Ù„ÙŠÙ„ ${symbol}...`);
                            
                            const data = await this.analyzeSymbol(symbol);
                            if (data && data.patternDetected) {
                                this.cryptoData.set(symbol, data);
                                console.log(`âœ… ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ù†Ù…Ø· ÙÙŠ ${symbol}: ${data.pattern}`);
                            }
                            
                            // Ø§Ù†ØªØ¸Ø§Ø± Ù‚ØµÙŠØ± Ø¨ÙŠÙ† Ø§Ù„Ø·Ù„Ø¨Ø§Øª
                            await this.sleep(200);
                            
                        } catch (error) {
                            console.warn(`âš ï¸ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ ${symbols[i]}:`, error.message);
                        }
                    }

                    console.log(`ğŸ¯ ØªÙ… Ø§ÙƒØªØ´Ø§Ù ${this.cryptoData.size} Ù†Ù…Ø·`);
                    this.renderCards();
                    
                } catch (error) {
                    console.error('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:', error);
                    this.showError('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.');
                } finally {
                    this.showLoading(false);
                }
            }

            async analyzeSymbol(symbol) {
                try {
                    // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ
                    const priceResponse = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`);
                    if (!priceResponse.ok) throw new Error('ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø¹Ø±');
                    const priceData = await priceResponse.json();

                    // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ù…ÙˆØ¹
                    const candlesResponse = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=100`);
                    if (!candlesResponse.ok) throw new Error('ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ù…ÙˆØ¹');
                    const candlesData = await candlesResponse.json();

                    const candles = candlesData.map(candle => ({
                        open: parseFloat(candle[1]),
                        high: parseFloat(candle[2]),
                        low: parseFloat(candle[3]),
                        close: parseFloat(candle[4]),
                        volume: parseFloat(candle[5]),
                        time: new Date(candle[0])
                    }));

                    // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø·
                    const pattern = this.detectPattern(candles);
                    if (!pattern.detected) return null;

                    return {
                        symbol: symbol,
                        name: symbol.replace('USDT', ''),
                        price: parseFloat(priceData.lastPrice),
                        change: parseFloat(priceData.priceChangePercent),
                        volume: parseFloat(priceData.volume),
                        pattern: pattern.type,
                        patternName: pattern.name,
                        confidence: pattern.confidence,
                        breakoutStatus: pattern.breakoutStatus,
                        signalStrength: pattern.signalStrength,
                        targets: pattern.targets,
                        patternDetected: true,
                        lastUpdate: new Date()
                    };

                } catch (error) {
                    console.warn(`ØªØ¹Ø°Ø± ØªØ­Ù„ÙŠÙ„ ${symbol}:`, error.message);
                    return null;
                }
            }

            detectPattern(candles) {
                if (candles.length < 50) {
                    return { detected: false };
                }

                // ØªØ­Ù„ÙŠÙ„ Ù…Ø¨Ø³Ø· Ù„Ù„Ø£Ù†Ù…Ø§Ø·
                const closes = candles.map(c => c.close);
                const highs = candles.map(c => c.high);
                const lows = candles.map(c => c.low);
                const volumes = candles.map(c => c.volume);

                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù‚Ø§Ø¹ Ù…Ø²Ø¯ÙˆØ¬
                const doubleBottom = this.findDoubleBottom(lows, volumes);
                if (doubleBottom.detected) return doubleBottom;

                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù‚Ù…Ø© Ù…Ø²Ø¯ÙˆØ¬Ø©
                const doubleTop = this.findDoubleTop(highs, volumes);
                if (doubleTop.detected) return doubleTop;

                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø«Ù„Ø« ØµØ§Ø¹Ø¯
                const ascendingTriangle = this.findAscendingTriangle(highs, lows);
                if (ascendingTriangle.detected) return ascendingTriangle;

                return { detected: false };
            }

            findDoubleBottom(lows, volumes) {
                const len = lows.length;
                if (len < 30) return { detected: false };

                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù‚Ø§Ø¹ÙŠÙ† Ù…ØªÙ‚Ø§Ø±Ø¨ÙŠÙ†
                for (let i = 10; i < len - 20; i++) {
                    for (let j = i + 10; j < len - 10; j++) {
                        const bottom1 = lows[i];
                        const bottom2 = lows[j];
                        const diff = Math.abs(bottom1 - bottom2) / bottom1;

                        if (diff < 0.03) { // ÙØ±Ù‚ Ø£Ù‚Ù„ Ù…Ù† 3%
                            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù‚Ù…Ø© Ø¨ÙŠÙ†Ù‡Ù…Ø§
                            const middleHigh = Math.max(...lows.slice(i, j));
                            const currentPrice = lows[len - 1];

                            if (middleHigh > bottom1 * 1.05) { // Ù‚Ù…Ø© Ø£Ø¹Ù„Ù‰ Ø¨Ù€ 5%
                                const confidence = this.calculateConfidence(diff, volumes, i, j);
                                const targets = this.calculateTargets(bottom1, middleHigh, 'bullish');

                                return {
                                    detected: true,
                                    type: 'double-bottom',
                                    name: 'Ø§Ù„Ù‚Ø§Ø¹ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬',
                                    confidence: `${Math.round(confidence)}%`,
                                    breakoutStatus: currentPrice > middleHigh ? 'Ù…Ø¤ÙƒØ¯' : 'ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ØªØ£ÙƒÙŠØ¯',
                                    signalStrength: confidence > 75 ? 'Ù‚ÙˆÙŠØ©' : confidence > 60 ? 'Ù…ØªÙˆØ³Ø·Ø©' : 'Ø¶Ø¹ÙŠÙØ©',
                                    targets: targets
                                };
                            }
                        }
                    }
                }

                return { detected: false };
            }

            findDoubleTop(highs, volumes) {
                const len = highs.length;
                if (len < 30) return { detected: false };

                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù‚Ù…ØªÙŠÙ† Ù…ØªÙ‚Ø§Ø±Ø¨ØªÙŠÙ†
                for (let i = 10; i < len - 20; i++) {
                    for (let j = i + 10; j < len - 10; j++) {
                        const top1 = highs[i];
                        const top2 = highs[j];
                        const diff = Math.abs(top1 - top2) / top1;

                        if (diff < 0.03) { // ÙØ±Ù‚ Ø£Ù‚Ù„ Ù…Ù† 3%
                            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù‚Ø§Ø¹ Ø¨ÙŠÙ†Ù‡Ù…Ø§
                            const middleLow = Math.min(...highs.slice(i, j));
                            const currentPrice = highs[len - 1];

                            if (middleLow < top1 * 0.95) { // Ù‚Ø§Ø¹ Ø£Ù‚Ù„ Ø¨Ù€ 5%
                                const confidence = this.calculateConfidence(diff, volumes, i, j);
                                const targets = this.calculateTargets(top1, middleLow, 'bearish');

                                return {
                                    detected: true,
                                    type: 'double-top',
                                    name: 'Ø§Ù„Ù‚Ù…Ø© Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬Ø©',
                                    confidence: `${Math.round(confidence)}%`,
                                    breakoutStatus: currentPrice < middleLow ? 'Ù…Ø¤ÙƒØ¯' : 'ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ØªØ£ÙƒÙŠØ¯',
                                    signalStrength: confidence > 75 ? 'Ù‚ÙˆÙŠØ©' : confidence > 60 ? 'Ù…ØªÙˆØ³Ø·Ø©' : 'Ø¶Ø¹ÙŠÙØ©',
                                    targets: targets
                                };
                            }
                        }
                    }
                }

                return { detected: false };
            }

            findAscendingTriangle(highs, lows) {
                const len = highs.length;
                if (len < 40) return { detected: false };

                const recent = len - 30;
                const recentHighs = highs.slice(recent);
                const recentLows = lows.slice(recent);

                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ù‚Ø§ÙˆÙ…Ø© Ø£ÙÙ‚ÙŠØ©
                const resistance = Math.max(...recentHighs);
                const resistanceCount = recentHighs.filter(h => Math.abs(h - resistance) / resistance < 0.02).length;

                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù‚ÙŠØ¹Ø§Ù† ØµØ§Ø¹Ø¯Ø©
                const lowTrend = this.calculateTrend(recentLows);

                if (resistanceCount >= 2 && lowTrend > 0) {
                    const confidence = Math.min(90, 60 + (resistanceCount * 5) + (lowTrend * 100));
                    const currentPrice = highs[len - 1];
                    const support = Math.min(...recentLows);
                    const targets = this.calculateTargets(resistance, support, 'bullish');

                    return {
                        detected: true,
                        type: 'ascending-triangle',
                        name: 'Ø§Ù„Ù…Ø«Ù„Ø« Ø§Ù„ØµØ§Ø¹Ø¯',
                        confidence: `${Math.round(confidence)}%`,
                        breakoutStatus: currentPrice > resistance ? 'Ù…Ø¤ÙƒØ¯' : 'ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ØªØ£ÙƒÙŠØ¯',
                        signalStrength: confidence > 75 ? 'Ù‚ÙˆÙŠØ©' : confidence > 60 ? 'Ù…ØªÙˆØ³Ø·Ø©' : 'Ø¶Ø¹ÙŠÙØ©',
                        targets: targets
                    };
                }

                return { detected: false };
            }

                       calculateConfidence(priceDiff, volumes, index1, index2) {
                let confidence = 70; // Ù‚Ø§Ø¹Ø¯Ø© Ø£Ø³Ø§Ø³ÙŠØ©

                // ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø«Ù‚Ø© ÙƒÙ„Ù…Ø§ Ø²Ø§Ø¯ Ø§Ù„ÙØ±Ù‚ Ø¨ÙŠÙ† Ø§Ù„Ù†Ù‚Ø§Ø·
                confidence -= (priceDiff * 1000); // ØªÙ‚Ù„ÙŠÙ„ Ø­Ø³Ø¨ Ø§Ù„ÙØ±Ù‚

                // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø«Ù‚Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø­Ø¬Ù… Ù…Ø±ØªÙØ¹ Ø¹Ù†Ø¯ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ù‡Ù…Ø©
                const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
                const volume1 = volumes[index1] || avgVolume;
                const volume2 = volumes[index2] || avgVolume;

                if (volume1 > avgVolume * 1.2) confidence += 5;
                if (volume2 > avgVolume * 1.2) confidence += 5;

                // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø«Ù‚Ø© ÙÙŠ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨
                return Math.max(50, Math.min(95, confidence));
            }

            calculateTargets(price1, price2, direction) {
                const range = Math.abs(price1 - price2);
                
                if (direction === 'bullish') {
                    const breakoutLevel = Math.max(price1, price2);
                    return {
                        target1: `$${(breakoutLevel + range * 0.618).toFixed(4)}`,
                        target2: `$${(breakoutLevel + range * 1.0).toFixed(4)}`,
                        stopLoss: `$${(Math.min(price1, price2) * 0.98).toFixed(4)}`
                    };
                } else {
                    const breakoutLevel = Math.min(price1, price2);
                    return {
                        target1: `$${(breakoutLevel - range * 0.618).toFixed(4)}`,
                        target2: `$${(breakoutLevel - range * 1.0).toFixed(4)}`,
                        stopLoss: `$${(Math.max(price1, price2) * 1.02).toFixed(4)}`
                    };
                }
            }

            calculateTrend(prices) {
                if (prices.length < 10) return 0;
                
                const n = prices.length;
                const sumX = (n * (n - 1)) / 2;
                const sumY = prices.reduce((a, b) => a + b, 0);
                const sumXY = prices.reduce((sum, price, index) => sum + (price * index), 0);
                const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                return slope / (sumY / n); // Ù†Ø³Ø¨Ø© Ø§Ù„Ù…ÙŠÙ„
            }

            renderCards() {
                const grid = document.getElementById('cardsGrid');
                
                if (this.cryptoData.size === 0) {
                    grid.innerHTML = `
                        <div class="error-message">
                            <i class="fas fa-search"></i>
                            <h3>Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£Ù†Ù…Ø§Ø· ÙÙ†ÙŠØ©</h3>
                            <p>Ø¬Ø±Ø¨ Ø§Ù„ØªØ­Ø¯ÙŠØ« Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø£Ùˆ ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØªØµØ§Ù„ Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª</p>
                        </div>
                    `;
                    return;
                }

                const cards = Array.from(this.cryptoData.values())
                    .sort((a, b) => {
                        // ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ Ù‚ÙˆØ© Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø«Ù… Ø§Ù„Ø«Ù‚Ø©
                        const strengthOrder = { 'Ù‚ÙˆÙŠØ©': 3, 'Ù…ØªÙˆØ³Ø·Ø©': 2, 'Ø¶Ø¹ÙŠÙØ©': 1 };
                        const aStrength = strengthOrder[a.signalStrength] || 0;
                        const bStrength = strengthOrder[b.signalStrength] || 0;
                        
                        if (aStrength !== bStrength) {
                            return bStrength - aStrength;
                        }
                        
                        const aConf = parseInt(a.confidence);
                        const bConf = parseInt(b.confidence);
                        return bConf - aConf;
                    })
                    .map(crypto => this.createCard(crypto))
                    .join('');

                grid.innerHTML = cards;
            }

            createCard(crypto) {
                const changeClass = crypto.change >= 0 ? 'positive' : 'negative';
                const changeIcon = crypto.change >= 0 ? 'fa-arrow-up' : 'fa-arrow-down';
                
                // ØªØ­Ø¯ÙŠØ¯ Ù„ÙˆÙ† Ù‚ÙˆØ© Ø§Ù„Ø¥Ø´Ø§Ø±Ø©
                const strengthColors = {
                    'Ù‚ÙˆÙŠØ©': '#2ed573',
                    'Ù…ØªÙˆØ³Ø·Ø©': '#ffa502',
                    'Ø¶Ø¹ÙŠÙØ©': '#ff4757'
                };
                
                const strengthColor = strengthColors[crypto.signalStrength] || '#888';
                
                // ØªØ­Ø¯ÙŠØ¯ Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„Ù†Ù…Ø·
                const patternIcons = {
                    'double-bottom': 'fa-chart-line',
                    'double-top': 'fa-chart-line',
                    'ascending-triangle': 'fa-play'
                };
                
                const patternIcon = patternIcons[crypto.pattern] || 'fa-chart-bar';

                return `
                    <div class="crypto-card" data-symbol="${crypto.symbol}">
                        <div class="card-header">
                            <div class="coin-info">
                                <h3><i class="fab fa-bitcoin"></i> ${crypto.name}</h3>
                                <span class="symbol">${crypto.symbol}</span>
                            </div>
                            <div class="price-info">
                                <div class="price">$${crypto.price.toFixed(4)}</div>
                                <div class="change ${changeClass}">
                                    <i class="fas ${changeIcon}"></i>
                                    ${crypto.change.toFixed(2)}%
                                </div>
                            </div>
                        </div>

                        <div class="pattern-info">
                            <div class="pattern-name">
                                <i class="fas ${patternIcon}"></i>
                                ${crypto.patternName}
                            </div>
                            <div class="pattern-details">
                                <div class="detail-item">
                                    <span class="detail-label">Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø©:</span>
                                    <span class="detail-value">${crypto.confidence}</span>
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Ù‚ÙˆØ© Ø§Ù„Ø¥Ø´Ø§Ø±Ø©:</span>
                                    <span class="detail-value" style="color: ${strengthColor}">
                                        ${crypto.signalStrength}
                                    </span>
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚:</span>
                                    <span class="detail-value">${crypto.breakoutStatus}</span>
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«:</span>
                                    <span class="detail-value">${this.formatTime(crypto.lastUpdate)}</span>
                                </div>
                            </div>
                        </div>

                        <div class="targets">
                            <div class="target target1">
                                <div style="font-weight: bold; margin-bottom: 0.25rem;">Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø£ÙˆÙ„</div>
                                <div>${crypto.targets.target1}</div>
                            </div>
                            <div class="target target2">
                                <div style="font-weight: bold; margin-bottom: 0.25rem;">Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø«Ø§Ù†ÙŠ</div>
                                <div>${crypto.targets.target2}</div>
                            </div>
                            <div class="target stop-loss">
                                <div style="font-weight: bold; margin-bottom: 0.25rem;">ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø©</div>
                                <div>${crypto.targets.stopLoss}</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            formatTime(date) {
                const now = new Date();
                const diff = now - date;
                const minutes = Math.floor(diff / 60000);
                
                if (minutes < 1) return 'Ø§Ù„Ø¢Ù†';
                if (minutes < 60) return `${minutes} Ø¯Ù‚ÙŠÙ‚Ø©`;
                
                const hours = Math.floor(minutes / 60);
                if (hours < 24) return `${hours} Ø³Ø§Ø¹Ø©`;
                
                const days = Math.floor(hours / 24);
                return `${days} ÙŠÙˆÙ…`;
            }

            filterCards(searchTerm) {
                const cards = document.querySelectorAll('.crypto-card');
                const term = searchTerm.toLowerCase();

                cards.forEach(card => {
                    const symbol = card.dataset.symbol.toLowerCase();
                    const name = card.querySelector('.coin-info h3').textContent.toLowerCase();
                    const pattern = card.querySelector('.pattern-name').textContent.toLowerCase();

                    if (symbol.includes(term) || name.includes(term) || pattern.includes(term)) {
                        card.style.display = 'block';
                    } else {
                        card.style.display = 'none';
                    }
                });
            }

            showError(message) {
                const grid = document.getElementById('cardsGrid');
                grid.innerHTML = `
                    <div class="error-message">
                        <i class="fas fa-exclamation-triangle"></i>
                        <h3>Ø­Ø¯Ø« Ø®Ø·Ø£</h3>
                        <p>${message}</p>
                        <button onclick="location.reload()" class="refresh-btn" style="margin-top: 1rem;">
                            Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
                        </button>
                    </div>
                `;
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸ¯ ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø© Ø¨Ù†Ø¬Ø§Ø­');
            new PatternDetector();
        });

        // Ø¥Ø¶Ø§ÙØ© ØªØ­Ø¯ÙŠØ« ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚
        setInterval(() => {
            console.log('ğŸ”„ ØªØ­Ø¯ÙŠØ« ØªÙ„Ù‚Ø§Ø¦ÙŠ...');
            if (window.patternDetector && !window.patternDetector.isLoading) {
                window.patternDetector.loadData();
            }
        }, 300000); // 5 Ø¯Ù‚Ø§Ø¦Ù‚

        // Ø­ÙØ¸ Ù…Ø±Ø¬Ø¹ Ù„Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
        document.addEventListener('DOMContentLoaded', () => {
            window.patternDetector = new PatternDetector();
        });
    </script>
</body>
</html>


